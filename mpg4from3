#!/usr/bin/perl
use 5.018 ; use strict ; use warnings ; 
use feature qw[say] ;
use Getopt::Std ; getopts 'd:ln', \my %o ; 
my @mp3files = grep { chomp ; $_ ne q[] } <*.mp3> ;
my $N = $o{n} ? "\\\n" : '' ; # 生成するコマンド文の途中に '\'の後に改行文字を、挿入するため。

for ( @mp3files ) {
  my $from = $_ ;
  s/[-]//g ; 
  s/[_+ ]/_/g ; 
  s/\.MP3$/.MP4/ ;
  s/\.mp3$/.mp4/i ;
  my $to = $_ ; 
  my $cmd = q[] ; 
  $cmd .= "time " ;
  $cmd .= qq[ffmpeg -loop 1 -i green.jpg -i "$from" $N] ; 
  $cmd .= " -c:v libx264 -tune stillimage " ; 
  $cmd .= " -c:a aac -strict experimental " ; 
  $cmd .= " -b:a 192k -pix_fmt yuv420p " ; 
  $cmd .= " -shortest '$to' ;" ;

  say $cmd if ! $o{l} ; 
  say "$from\t-->\t$to" if $o{l} ;	
  qx[$cmd] if ($o{d}//'') eq 'o' ; # -do または -d o というオプションになっていたら、生成したコマンド文を実行する。
}


## ヘルプの扱い
sub VERSION_MESSAGE {}
sub HELP_MESSAGE {
  use FindBin qw[ $Script ] ; 
  $ARGV[1] //= '' ;
  open my $FH , '<' , $0 ;
  while(<$FH>){
    s/\$0/$Script/g ;
    print $_ if s/^=head1// .. s/^=cut// and $ARGV[1] =~ /^o(p(t(i(o(ns?)?)?)?)?)?$/i ? m/^\s+\-/ : 1;
  }
  close $FH ;
  exit 0 ;
}

=encoding utf8

=head1 

  $0 

    mp3ファイルをmp4ファイルに(画像green.ppgを使って静止画像を加えて)変換する
    コマンド文を出力する。このコマンドを実行する際に、そのディレクトリ(カレントディレクトリ)に
    含まれているmp4 形式のファイルを全て使う。

 オプション :

    -do  : 生成するコマンド文を、システム上で実行する。(単にコマンド文を見せるだけではない。)
    -l : 元のmp3ファイルがどう変換されるかを(TSV形式で)出力する。
    -n : コマンド文を視覚的に 分かりやすくするために、改行文字を途中に挿入する。

 注意 : 

   1. このコマンドは システムに ffmpeg がインストールされていることを前提とする。OSXなら brew intall ffmpeg 実行するなどすること。
   2. green.jpg という、縦と横の画素数が偶数の画像の用意が必要である。

=cut

